/**

Generated by the following Solidity interface...
```solidity
interface L1Scroller {
    function bytes32ToString(bytes32 _bytes32) external pure returns (string memory);
    function bytesToUint(bytes memory b) external pure returns (uint256);
    function readAddress(address l1_contract, uint256 slot) external view returns (address);
    function readMultipleSlots(address l1_contract, uint256[] memory slot) external view returns (bytes memory);
    function readSlot(address l1_contract, uint256 slot) external view returns (bytes memory);
    function readString(address l1_contract, uint256 slot) external view returns (string memory);
    function readUint(address l1_contract, uint256 slot) external view returns (uint256);
    function readUint128(address l1_contract, uint256 slot) external view returns (uint128);
    function readUint160(address l1_contract, uint256 slot) external view returns (uint160);
    function readUint24(address l1_contract, uint256 slot) external view returns (uint24);
    function readUint32(address l1_contract, uint256 slot) external view returns (uint32);
    function readUint48(address l1_contract, uint256 slot) external view returns (uint48);
    function readUint64(address l1_contract, uint256 slot) external view returns (uint64);
    function readUint8(address l1_contract, uint256 slot) external view returns (uint8);
    function readUint96(address l1_contract, uint256 slot) external view returns (uint96);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "function",
    "name": "bytes32ToString",
    "inputs": [
      {
        "name": "_bytes32",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "bytesToUint",
    "inputs": [
      {
        "name": "b",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "readAddress",
    "inputs": [
      {
        "name": "l1_contract",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "slot",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "readMultipleSlots",
    "inputs": [
      {
        "name": "l1_contract",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "slot",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "readSlot",
    "inputs": [
      {
        "name": "l1_contract",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "slot",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "readString",
    "inputs": [
      {
        "name": "l1_contract",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "slot",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "readUint",
    "inputs": [
      {
        "name": "l1_contract",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "slot",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "readUint128",
    "inputs": [
      {
        "name": "l1_contract",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "slot",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint128",
        "internalType": "uint128"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "readUint160",
    "inputs": [
      {
        "name": "l1_contract",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "slot",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint160",
        "internalType": "uint160"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "readUint24",
    "inputs": [
      {
        "name": "l1_contract",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "slot",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint24",
        "internalType": "uint24"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "readUint32",
    "inputs": [
      {
        "name": "l1_contract",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "slot",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "readUint48",
    "inputs": [
      {
        "name": "l1_contract",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "slot",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint48",
        "internalType": "uint48"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "readUint64",
    "inputs": [
      {
        "name": "l1_contract",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "slot",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "readUint8",
    "inputs": [
      {
        "name": "l1_contract",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "slot",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint8",
        "internalType": "uint8"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "readUint96",
    "inputs": [
      {
        "name": "l1_contract",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "slot",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint96",
        "internalType": "uint96"
      }
    ],
    "stateMutability": "view"
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style
)]
pub mod L1Scroller {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x6080604052348015600f57600080fd5b506108268061001f6000396000f3fe608060405234801561001057600080fd5b50600436106100f55760003560e01c8063a17a41a111610097578063bc0b03c911610066578063bc0b03c914610250578063c4e1b1a914610272578063d645650514610285578063fdb070a5146102aa57600080fd5b8063a17a41a1146101f9578063a2a81a7814610207578063ac09f5df1461022a578063bae725651461022a57600080fd5b806351987477116100d3578063519874771461016c57806351b5c4cd146101975780638af77671146101c65780639201de55146101e657600080fd5b806302d06d05146100fa57806306fa88231461012057806326fee5d81461014c575b600080fd5b61010d610108366004610509565b6102bd565b6040519081526020015b60405180910390f35b61013361012e3660046105bf565b6102d9565b60405167ffffffffffffffff9091168152602001610117565b61015f61015a3660046105e9565b6102f9565b60405161011791906106fd565b61017a61012e3660046105bf565b6040516bffffffffffffffffffffffff9091168152602001610117565b6101a561012e3660046105bf565b6040516fffffffffffffffffffffffffffffffff9091168152602001610117565b6101d461012e3660046105bf565b60405160ff9091168152602001610117565b61015f6101f4366004610717565b6103d3565b61010d61012e3660046105bf565b61021561012e3660046105bf565b60405163ffffffff9091168152602001610117565b61023861012e3660046105bf565b6040516001600160a01b039091168152602001610117565b61025e61012e3660046105bf565b60405162ffffff9091168152602001610117565b61015f6102803660046105bf565b610477565b61029361012e3660046105bf565b60405165ffffffffffff9091168152602001610117565b61015f6102b83660046105bf565b610493565b6000818060200190518101906102d39190610730565b92915050565b6000806102e68484610493565b90506102f1816102bd565b949350505050565b606060008383604051602001610310929190610749565b60405160208183030381529060405290506000806101016001600160a01b03168360405161033e9190610797565b600060405180830381855afa9150503d8060008114610379576040519150601f19603f3d011682016040523d82523d6000602084013e61037e565b606091505b5091509150816103ca5760405162461bcd60e51b815260206004820152601360248201527211985a5b1959081d1bc81c995859081cdb1bdd606a1b604482015260640160405180910390fd5b95945050505050565b6040805160208082528183019092526060916000919060208201818036833701905050905060005b602081101561047057838160208110610416576104166107b3565b1a60f81b6001600160f81b031916156104705783816020811061043b5761043b6107b3565b1a60f81b828281518110610451576104516107b3565b60200101906001600160f81b031916908160001a9053506001016103fb565b5092915050565b606060006104858484610493565b90506102f16101f4826107c9565b604051606083811b6bffffffffffffffffffffffff191660208301526034820183905290600090605401610310565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f1916810167ffffffffffffffff81118282101715610501576105016104c2565b604052919050565b60006020828403121561051b57600080fd5b813567ffffffffffffffff81111561053257600080fd5b8201601f8101841361054357600080fd5b803567ffffffffffffffff81111561055d5761055d6104c2565b610570601f8201601f19166020016104d8565b81815285602083850101111561058557600080fd5b81602084016020830137600091810160200191909152949350505050565b80356001600160a01b03811681146105ba57600080fd5b919050565b600080604083850312156105d257600080fd5b6105db836105a3565b946020939093013593505050565b600080604083850312156105fc57600080fd5b610605836105a3565b9150602083013567ffffffffffffffff81111561062157600080fd5b8301601f8101851361063257600080fd5b803567ffffffffffffffff81111561064c5761064c6104c2565b8060051b61065c602082016104d8565b9182526020818401810192908101908884111561067857600080fd5b6020850194505b8385101561069e5784358083526020958601959093509091019061067f565b80955050505050509250929050565b60005b838110156106c85781810151838201526020016106b0565b50506000910152565b600081518084526106e98160208601602086016106ad565b601f01601f19169290920160200192915050565b60208152600061071060208301846106d1565b9392505050565b60006020828403121561072957600080fd5b5035919050565b60006020828403121561074257600080fd5b5051919050565b6bffffffffffffffffffffffff198360601b16815260006014820183516020850160005b8281101561078b57815184526020938401939091019060010161076d565b50919695505050505050565b600082516107a98184602087016106ad565b9190910192915050565b634e487b7160e01b600052603260045260246000fd5b805160208083015191908110156107ea576000198160200360031b1b821691505b5091905056fea2646970667358221220387da8f1c0938acc789687653f09c60704b05e41457284d844d43d6550ccdb0864736f6c634300081a0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15`\x0FW`\0\x80\xFD[Pa\x08&\x80a\0\x1F`\09`\0\xF3\xFE`\x80`@R4\x80\x15a\0\x10W`\0\x80\xFD[P`\x046\x10a\0\xF5W`\x005`\xE0\x1C\x80c\xA1zA\xA1\x11a\0\x97W\x80c\xBC\x0B\x03\xC9\x11a\0fW\x80c\xBC\x0B\x03\xC9\x14a\x02PW\x80c\xC4\xE1\xB1\xA9\x14a\x02rW\x80c\xD6Ee\x05\x14a\x02\x85W\x80c\xFD\xB0p\xA5\x14a\x02\xAAW`\0\x80\xFD[\x80c\xA1zA\xA1\x14a\x01\xF9W\x80c\xA2\xA8\x1Ax\x14a\x02\x07W\x80c\xAC\t\xF5\xDF\x14a\x02*W\x80c\xBA\xE7%e\x14a\x02*W`\0\x80\xFD[\x80cQ\x98tw\x11a\0\xD3W\x80cQ\x98tw\x14a\x01lW\x80cQ\xB5\xC4\xCD\x14a\x01\x97W\x80c\x8A\xF7vq\x14a\x01\xC6W\x80c\x92\x01\xDEU\x14a\x01\xE6W`\0\x80\xFD[\x80c\x02\xD0m\x05\x14a\0\xFAW\x80c\x06\xFA\x88#\x14a\x01 W\x80c&\xFE\xE5\xD8\x14a\x01LW[`\0\x80\xFD[a\x01\ra\x01\x086`\x04a\x05\tV[a\x02\xBDV[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\x013a\x01.6`\x04a\x05\xBFV[a\x02\xD9V[`@Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16\x81R` \x01a\x01\x17V[a\x01_a\x01Z6`\x04a\x05\xE9V[a\x02\xF9V[`@Qa\x01\x17\x91\x90a\x06\xFDV[a\x01za\x01.6`\x04a\x05\xBFV[`@Qk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16\x81R` \x01a\x01\x17V[a\x01\xA5a\x01.6`\x04a\x05\xBFV[`@Qo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16\x81R` \x01a\x01\x17V[a\x01\xD4a\x01.6`\x04a\x05\xBFV[`@Q`\xFF\x90\x91\x16\x81R` \x01a\x01\x17V[a\x01_a\x01\xF46`\x04a\x07\x17V[a\x03\xD3V[a\x01\ra\x01.6`\x04a\x05\xBFV[a\x02\x15a\x01.6`\x04a\x05\xBFV[`@Qc\xFF\xFF\xFF\xFF\x90\x91\x16\x81R` \x01a\x01\x17V[a\x028a\x01.6`\x04a\x05\xBFV[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x01\x17V[a\x02^a\x01.6`\x04a\x05\xBFV[`@Qb\xFF\xFF\xFF\x90\x91\x16\x81R` \x01a\x01\x17V[a\x01_a\x02\x806`\x04a\x05\xBFV[a\x04wV[a\x02\x93a\x01.6`\x04a\x05\xBFV[`@Qe\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16\x81R` \x01a\x01\x17V[a\x01_a\x02\xB86`\x04a\x05\xBFV[a\x04\x93V[`\0\x81\x80` \x01\x90Q\x81\x01\x90a\x02\xD3\x91\x90a\x070V[\x92\x91PPV[`\0\x80a\x02\xE6\x84\x84a\x04\x93V[\x90Pa\x02\xF1\x81a\x02\xBDV[\x94\x93PPPPV[```\0\x83\x83`@Q` \x01a\x03\x10\x92\x91\x90a\x07IV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x90P`\0\x80a\x01\x01`\x01`\x01`\xA0\x1B\x03\x16\x83`@Qa\x03>\x91\x90a\x07\x97V[`\0`@Q\x80\x83\x03\x81\x85Z\xFA\x91PP=\x80`\0\x81\x14a\x03yW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=`\0` \x84\x01>a\x03~V[``\x91P[P\x91P\x91P\x81a\x03\xCAW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x13`$\x82\x01Rr\x11\x98Z[\x19Y\x08\x1D\x1B\xC8\x1C\x99XY\x08\x1C\xDB\x1B\xDD`j\x1B`D\x82\x01R`d\x01`@Q\x80\x91\x03\x90\xFD[\x95\x94PPPPPV[`@\x80Q` \x80\x82R\x81\x83\x01\x90\x92R``\x91`\0\x91\x90` \x82\x01\x81\x806\x837\x01\x90PP\x90P`\0[` \x81\x10\x15a\x04pW\x83\x81` \x81\x10a\x04\x16Wa\x04\x16a\x07\xB3V[\x1A`\xF8\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16\x15a\x04pW\x83\x81` \x81\x10a\x04;Wa\x04;a\x07\xB3V[\x1A`\xF8\x1B\x82\x82\x81Q\x81\x10a\x04QWa\x04Qa\x07\xB3V[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81`\0\x1A\x90SP`\x01\x01a\x03\xFBV[P\x92\x91PPV[```\0a\x04\x85\x84\x84a\x04\x93V[\x90Pa\x02\xF1a\x01\xF4\x82a\x07\xC9V[`@Q``\x83\x81\x1Bk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16` \x83\x01R`4\x82\x01\x83\x90R\x90`\0\x90`T\x01a\x03\x10V[cNH{q`\xE0\x1B`\0R`A`\x04R`$`\0\xFD[`@Q`\x1F\x82\x01`\x1F\x19\x16\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\x05\x01Wa\x05\x01a\x04\xC2V[`@R\x91\x90PV[`\0` \x82\x84\x03\x12\x15a\x05\x1BW`\0\x80\xFD[\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x052W`\0\x80\xFD[\x82\x01`\x1F\x81\x01\x84\x13a\x05CW`\0\x80\xFD[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x05]Wa\x05]a\x04\xC2V[a\x05p`\x1F\x82\x01`\x1F\x19\x16` \x01a\x04\xD8V[\x81\x81R\x85` \x83\x85\x01\x01\x11\x15a\x05\x85W`\0\x80\xFD[\x81` \x84\x01` \x83\x017`\0\x91\x81\x01` \x01\x91\x90\x91R\x94\x93PPPPV[\x805`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x05\xBAW`\0\x80\xFD[\x91\x90PV[`\0\x80`@\x83\x85\x03\x12\x15a\x05\xD2W`\0\x80\xFD[a\x05\xDB\x83a\x05\xA3V[\x94` \x93\x90\x93\x015\x93PPPV[`\0\x80`@\x83\x85\x03\x12\x15a\x05\xFCW`\0\x80\xFD[a\x06\x05\x83a\x05\xA3V[\x91P` \x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x06!W`\0\x80\xFD[\x83\x01`\x1F\x81\x01\x85\x13a\x062W`\0\x80\xFD[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x06LWa\x06La\x04\xC2V[\x80`\x05\x1Ba\x06\\` \x82\x01a\x04\xD8V[\x91\x82R` \x81\x84\x01\x81\x01\x92\x90\x81\x01\x90\x88\x84\x11\x15a\x06xW`\0\x80\xFD[` \x85\x01\x94P[\x83\x85\x10\x15a\x06\x9EW\x845\x80\x83R` \x95\x86\x01\x95\x90\x93P\x90\x91\x01\x90a\x06\x7FV[\x80\x95PPPPPP\x92P\x92\x90PV[`\0[\x83\x81\x10\x15a\x06\xC8W\x81\x81\x01Q\x83\x82\x01R` \x01a\x06\xB0V[PP`\0\x91\x01RV[`\0\x81Q\x80\x84Ra\x06\xE9\x81` \x86\x01` \x86\x01a\x06\xADV[`\x1F\x01`\x1F\x19\x16\x92\x90\x92\x01` \x01\x92\x91PPV[` \x81R`\0a\x07\x10` \x83\x01\x84a\x06\xD1V[\x93\x92PPPV[`\0` \x82\x84\x03\x12\x15a\x07)W`\0\x80\xFD[P5\x91\x90PV[`\0` \x82\x84\x03\x12\x15a\x07BW`\0\x80\xFD[PQ\x91\x90PV[k\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x83``\x1B\x16\x81R`\0`\x14\x82\x01\x83Q` \x85\x01`\0[\x82\x81\x10\x15a\x07\x8BW\x81Q\x84R` \x93\x84\x01\x93\x90\x91\x01\x90`\x01\x01a\x07mV[P\x91\x96\x95PPPPPPV[`\0\x82Qa\x07\xA9\x81\x84` \x87\x01a\x06\xADV[\x91\x90\x91\x01\x92\x91PPV[cNH{q`\xE0\x1B`\0R`2`\x04R`$`\0\xFD[\x80Q` \x80\x83\x01Q\x91\x90\x81\x10\x15a\x07\xEAW`\0\x19\x81` \x03`\x03\x1B\x1B\x82\x16\x91P[P\x91\x90PV\xFE\xA2dipfsX\"\x12 8}\xA8\xF1\xC0\x93\x8A\xCCx\x96\x87e?\t\xC6\x07\x04\xB0^AEr\x84\xD8D\xD4=eP\xCC\xDB\x08dsolcC\0\x08\x1A\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561001057600080fd5b50600436106100f55760003560e01c8063a17a41a111610097578063bc0b03c911610066578063bc0b03c914610250578063c4e1b1a914610272578063d645650514610285578063fdb070a5146102aa57600080fd5b8063a17a41a1146101f9578063a2a81a7814610207578063ac09f5df1461022a578063bae725651461022a57600080fd5b806351987477116100d3578063519874771461016c57806351b5c4cd146101975780638af77671146101c65780639201de55146101e657600080fd5b806302d06d05146100fa57806306fa88231461012057806326fee5d81461014c575b600080fd5b61010d610108366004610509565b6102bd565b6040519081526020015b60405180910390f35b61013361012e3660046105bf565b6102d9565b60405167ffffffffffffffff9091168152602001610117565b61015f61015a3660046105e9565b6102f9565b60405161011791906106fd565b61017a61012e3660046105bf565b6040516bffffffffffffffffffffffff9091168152602001610117565b6101a561012e3660046105bf565b6040516fffffffffffffffffffffffffffffffff9091168152602001610117565b6101d461012e3660046105bf565b60405160ff9091168152602001610117565b61015f6101f4366004610717565b6103d3565b61010d61012e3660046105bf565b61021561012e3660046105bf565b60405163ffffffff9091168152602001610117565b61023861012e3660046105bf565b6040516001600160a01b039091168152602001610117565b61025e61012e3660046105bf565b60405162ffffff9091168152602001610117565b61015f6102803660046105bf565b610477565b61029361012e3660046105bf565b60405165ffffffffffff9091168152602001610117565b61015f6102b83660046105bf565b610493565b6000818060200190518101906102d39190610730565b92915050565b6000806102e68484610493565b90506102f1816102bd565b949350505050565b606060008383604051602001610310929190610749565b60405160208183030381529060405290506000806101016001600160a01b03168360405161033e9190610797565b600060405180830381855afa9150503d8060008114610379576040519150601f19603f3d011682016040523d82523d6000602084013e61037e565b606091505b5091509150816103ca5760405162461bcd60e51b815260206004820152601360248201527211985a5b1959081d1bc81c995859081cdb1bdd606a1b604482015260640160405180910390fd5b95945050505050565b6040805160208082528183019092526060916000919060208201818036833701905050905060005b602081101561047057838160208110610416576104166107b3565b1a60f81b6001600160f81b031916156104705783816020811061043b5761043b6107b3565b1a60f81b828281518110610451576104516107b3565b60200101906001600160f81b031916908160001a9053506001016103fb565b5092915050565b606060006104858484610493565b90506102f16101f4826107c9565b604051606083811b6bffffffffffffffffffffffff191660208301526034820183905290600090605401610310565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f1916810167ffffffffffffffff81118282101715610501576105016104c2565b604052919050565b60006020828403121561051b57600080fd5b813567ffffffffffffffff81111561053257600080fd5b8201601f8101841361054357600080fd5b803567ffffffffffffffff81111561055d5761055d6104c2565b610570601f8201601f19166020016104d8565b81815285602083850101111561058557600080fd5b81602084016020830137600091810160200191909152949350505050565b80356001600160a01b03811681146105ba57600080fd5b919050565b600080604083850312156105d257600080fd5b6105db836105a3565b946020939093013593505050565b600080604083850312156105fc57600080fd5b610605836105a3565b9150602083013567ffffffffffffffff81111561062157600080fd5b8301601f8101851361063257600080fd5b803567ffffffffffffffff81111561064c5761064c6104c2565b8060051b61065c602082016104d8565b9182526020818401810192908101908884111561067857600080fd5b6020850194505b8385101561069e5784358083526020958601959093509091019061067f565b80955050505050509250929050565b60005b838110156106c85781810151838201526020016106b0565b50506000910152565b600081518084526106e98160208601602086016106ad565b601f01601f19169290920160200192915050565b60208152600061071060208301846106d1565b9392505050565b60006020828403121561072957600080fd5b5035919050565b60006020828403121561074257600080fd5b5051919050565b6bffffffffffffffffffffffff198360601b16815260006014820183516020850160005b8281101561078b57815184526020938401939091019060010161076d565b50919695505050505050565b600082516107a98184602087016106ad565b9190910192915050565b634e487b7160e01b600052603260045260246000fd5b805160208083015191908110156107ea576000198160200360031b1b821691505b5091905056fea2646970667358221220387da8f1c0938acc789687653f09c60704b05e41457284d844d43d6550ccdb0864736f6c634300081a0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x10W`\0\x80\xFD[P`\x046\x10a\0\xF5W`\x005`\xE0\x1C\x80c\xA1zA\xA1\x11a\0\x97W\x80c\xBC\x0B\x03\xC9\x11a\0fW\x80c\xBC\x0B\x03\xC9\x14a\x02PW\x80c\xC4\xE1\xB1\xA9\x14a\x02rW\x80c\xD6Ee\x05\x14a\x02\x85W\x80c\xFD\xB0p\xA5\x14a\x02\xAAW`\0\x80\xFD[\x80c\xA1zA\xA1\x14a\x01\xF9W\x80c\xA2\xA8\x1Ax\x14a\x02\x07W\x80c\xAC\t\xF5\xDF\x14a\x02*W\x80c\xBA\xE7%e\x14a\x02*W`\0\x80\xFD[\x80cQ\x98tw\x11a\0\xD3W\x80cQ\x98tw\x14a\x01lW\x80cQ\xB5\xC4\xCD\x14a\x01\x97W\x80c\x8A\xF7vq\x14a\x01\xC6W\x80c\x92\x01\xDEU\x14a\x01\xE6W`\0\x80\xFD[\x80c\x02\xD0m\x05\x14a\0\xFAW\x80c\x06\xFA\x88#\x14a\x01 W\x80c&\xFE\xE5\xD8\x14a\x01LW[`\0\x80\xFD[a\x01\ra\x01\x086`\x04a\x05\tV[a\x02\xBDV[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\x013a\x01.6`\x04a\x05\xBFV[a\x02\xD9V[`@Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16\x81R` \x01a\x01\x17V[a\x01_a\x01Z6`\x04a\x05\xE9V[a\x02\xF9V[`@Qa\x01\x17\x91\x90a\x06\xFDV[a\x01za\x01.6`\x04a\x05\xBFV[`@Qk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16\x81R` \x01a\x01\x17V[a\x01\xA5a\x01.6`\x04a\x05\xBFV[`@Qo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16\x81R` \x01a\x01\x17V[a\x01\xD4a\x01.6`\x04a\x05\xBFV[`@Q`\xFF\x90\x91\x16\x81R` \x01a\x01\x17V[a\x01_a\x01\xF46`\x04a\x07\x17V[a\x03\xD3V[a\x01\ra\x01.6`\x04a\x05\xBFV[a\x02\x15a\x01.6`\x04a\x05\xBFV[`@Qc\xFF\xFF\xFF\xFF\x90\x91\x16\x81R` \x01a\x01\x17V[a\x028a\x01.6`\x04a\x05\xBFV[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x01\x17V[a\x02^a\x01.6`\x04a\x05\xBFV[`@Qb\xFF\xFF\xFF\x90\x91\x16\x81R` \x01a\x01\x17V[a\x01_a\x02\x806`\x04a\x05\xBFV[a\x04wV[a\x02\x93a\x01.6`\x04a\x05\xBFV[`@Qe\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16\x81R` \x01a\x01\x17V[a\x01_a\x02\xB86`\x04a\x05\xBFV[a\x04\x93V[`\0\x81\x80` \x01\x90Q\x81\x01\x90a\x02\xD3\x91\x90a\x070V[\x92\x91PPV[`\0\x80a\x02\xE6\x84\x84a\x04\x93V[\x90Pa\x02\xF1\x81a\x02\xBDV[\x94\x93PPPPV[```\0\x83\x83`@Q` \x01a\x03\x10\x92\x91\x90a\x07IV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x90P`\0\x80a\x01\x01`\x01`\x01`\xA0\x1B\x03\x16\x83`@Qa\x03>\x91\x90a\x07\x97V[`\0`@Q\x80\x83\x03\x81\x85Z\xFA\x91PP=\x80`\0\x81\x14a\x03yW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=`\0` \x84\x01>a\x03~V[``\x91P[P\x91P\x91P\x81a\x03\xCAW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x13`$\x82\x01Rr\x11\x98Z[\x19Y\x08\x1D\x1B\xC8\x1C\x99XY\x08\x1C\xDB\x1B\xDD`j\x1B`D\x82\x01R`d\x01`@Q\x80\x91\x03\x90\xFD[\x95\x94PPPPPV[`@\x80Q` \x80\x82R\x81\x83\x01\x90\x92R``\x91`\0\x91\x90` \x82\x01\x81\x806\x837\x01\x90PP\x90P`\0[` \x81\x10\x15a\x04pW\x83\x81` \x81\x10a\x04\x16Wa\x04\x16a\x07\xB3V[\x1A`\xF8\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16\x15a\x04pW\x83\x81` \x81\x10a\x04;Wa\x04;a\x07\xB3V[\x1A`\xF8\x1B\x82\x82\x81Q\x81\x10a\x04QWa\x04Qa\x07\xB3V[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81`\0\x1A\x90SP`\x01\x01a\x03\xFBV[P\x92\x91PPV[```\0a\x04\x85\x84\x84a\x04\x93V[\x90Pa\x02\xF1a\x01\xF4\x82a\x07\xC9V[`@Q``\x83\x81\x1Bk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16` \x83\x01R`4\x82\x01\x83\x90R\x90`\0\x90`T\x01a\x03\x10V[cNH{q`\xE0\x1B`\0R`A`\x04R`$`\0\xFD[`@Q`\x1F\x82\x01`\x1F\x19\x16\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\x05\x01Wa\x05\x01a\x04\xC2V[`@R\x91\x90PV[`\0` \x82\x84\x03\x12\x15a\x05\x1BW`\0\x80\xFD[\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x052W`\0\x80\xFD[\x82\x01`\x1F\x81\x01\x84\x13a\x05CW`\0\x80\xFD[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x05]Wa\x05]a\x04\xC2V[a\x05p`\x1F\x82\x01`\x1F\x19\x16` \x01a\x04\xD8V[\x81\x81R\x85` \x83\x85\x01\x01\x11\x15a\x05\x85W`\0\x80\xFD[\x81` \x84\x01` \x83\x017`\0\x91\x81\x01` \x01\x91\x90\x91R\x94\x93PPPPV[\x805`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x05\xBAW`\0\x80\xFD[\x91\x90PV[`\0\x80`@\x83\x85\x03\x12\x15a\x05\xD2W`\0\x80\xFD[a\x05\xDB\x83a\x05\xA3V[\x94` \x93\x90\x93\x015\x93PPPV[`\0\x80`@\x83\x85\x03\x12\x15a\x05\xFCW`\0\x80\xFD[a\x06\x05\x83a\x05\xA3V[\x91P` \x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x06!W`\0\x80\xFD[\x83\x01`\x1F\x81\x01\x85\x13a\x062W`\0\x80\xFD[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x06LWa\x06La\x04\xC2V[\x80`\x05\x1Ba\x06\\` \x82\x01a\x04\xD8V[\x91\x82R` \x81\x84\x01\x81\x01\x92\x90\x81\x01\x90\x88\x84\x11\x15a\x06xW`\0\x80\xFD[` \x85\x01\x94P[\x83\x85\x10\x15a\x06\x9EW\x845\x80\x83R` \x95\x86\x01\x95\x90\x93P\x90\x91\x01\x90a\x06\x7FV[\x80\x95PPPPPP\x92P\x92\x90PV[`\0[\x83\x81\x10\x15a\x06\xC8W\x81\x81\x01Q\x83\x82\x01R` \x01a\x06\xB0V[PP`\0\x91\x01RV[`\0\x81Q\x80\x84Ra\x06\xE9\x81` \x86\x01` \x86\x01a\x06\xADV[`\x1F\x01`\x1F\x19\x16\x92\x90\x92\x01` \x01\x92\x91PPV[` \x81R`\0a\x07\x10` \x83\x01\x84a\x06\xD1V[\x93\x92PPPV[`\0` \x82\x84\x03\x12\x15a\x07)W`\0\x80\xFD[P5\x91\x90PV[`\0` \x82\x84\x03\x12\x15a\x07BW`\0\x80\xFD[PQ\x91\x90PV[k\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x83``\x1B\x16\x81R`\0`\x14\x82\x01\x83Q` \x85\x01`\0[\x82\x81\x10\x15a\x07\x8BW\x81Q\x84R` \x93\x84\x01\x93\x90\x91\x01\x90`\x01\x01a\x07mV[P\x91\x96\x95PPPPPPV[`\0\x82Qa\x07\xA9\x81\x84` \x87\x01a\x06\xADV[\x91\x90\x91\x01\x92\x91PPV[cNH{q`\xE0\x1B`\0R`2`\x04R`$`\0\xFD[\x80Q` \x80\x83\x01Q\x91\x90\x81\x10\x15a\x07\xEAW`\0\x19\x81` \x03`\x03\x1B\x1B\x82\x16\x91P[P\x91\x90PV\xFE\xA2dipfsX\"\x12 8}\xA8\xF1\xC0\x93\x8A\xCCx\x96\x87e?\t\xC6\x07\x04\xB0^AEr\x84\xD8D\xD4=eP\xCC\xDB\x08dsolcC\0\x08\x1A\x003",
    );
    /**Function with signature `bytes32ToString(bytes32)` and selector `0x9201de55`.
```solidity
function bytes32ToString(bytes32 _bytes32) external pure returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bytes32ToStringCall {
        pub _bytes32: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`bytes32ToString(bytes32)`](bytes32ToStringCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bytes32ToStringReturn {
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bytes32ToStringCall> for UnderlyingRustTuple<'_> {
                fn from(value: bytes32ToStringCall) -> Self {
                    (value._bytes32,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bytes32ToStringCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _bytes32: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bytes32ToStringReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: bytes32ToStringReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for bytes32ToStringReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bytes32ToStringCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bytes32ToStringReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bytes32ToString(bytes32)";
            const SELECTOR: [u8; 4] = [146u8, 1u8, 222u8, 85u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._bytes32),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bytesToUint(bytes)` and selector `0x02d06d05`.
```solidity
function bytesToUint(bytes memory b) external pure returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bytesToUintCall {
        pub b: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`bytesToUint(bytes)`](bytesToUintCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bytesToUintReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bytesToUintCall> for UnderlyingRustTuple<'_> {
                fn from(value: bytesToUintCall) -> Self {
                    (value.b,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bytesToUintCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { b: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bytesToUintReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bytesToUintReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bytesToUintReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bytesToUintCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bytes,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bytesToUintReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bytesToUint(bytes)";
            const SELECTOR: [u8; 4] = [2u8, 208u8, 109u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.b,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `readAddress(address,uint256)` and selector `0xbae72565`.
```solidity
function readAddress(address l1_contract, uint256 slot) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readAddressCall {
        pub l1_contract: alloy::sol_types::private::Address,
        pub slot: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`readAddress(address,uint256)`](readAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readAddressReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readAddressCall> for UnderlyingRustTuple<'_> {
                fn from(value: readAddressCall) -> Self {
                    (value.l1_contract, value.slot)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        l1_contract: tuple.0,
                        slot: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readAddressReturn> for UnderlyingRustTuple<'_> {
                fn from(value: readAddressReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for readAddressCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = readAddressReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "readAddress(address,uint256)";
            const SELECTOR: [u8; 4] = [186u8, 231u8, 37u8, 101u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.l1_contract,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.slot),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `readMultipleSlots(address,uint256[])` and selector `0x26fee5d8`.
```solidity
function readMultipleSlots(address l1_contract, uint256[] memory slot) external view returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readMultipleSlotsCall {
        pub l1_contract: alloy::sol_types::private::Address,
        pub slot: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
    }
    ///Container type for the return parameters of the [`readMultipleSlots(address,uint256[])`](readMultipleSlotsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readMultipleSlotsReturn {
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readMultipleSlotsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: readMultipleSlotsCall) -> Self {
                    (value.l1_contract, value.slot)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for readMultipleSlotsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        l1_contract: tuple.0,
                        slot: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readMultipleSlotsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: readMultipleSlotsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for readMultipleSlotsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for readMultipleSlotsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = readMultipleSlotsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "readMultipleSlots(address,uint256[])";
            const SELECTOR: [u8; 4] = [38u8, 254u8, 229u8, 216u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.l1_contract,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.slot),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `readSlot(address,uint256)` and selector `0xfdb070a5`.
```solidity
function readSlot(address l1_contract, uint256 slot) external view returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readSlotCall {
        pub l1_contract: alloy::sol_types::private::Address,
        pub slot: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`readSlot(address,uint256)`](readSlotCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readSlotReturn {
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readSlotCall> for UnderlyingRustTuple<'_> {
                fn from(value: readSlotCall) -> Self {
                    (value.l1_contract, value.slot)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readSlotCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        l1_contract: tuple.0,
                        slot: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readSlotReturn> for UnderlyingRustTuple<'_> {
                fn from(value: readSlotReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readSlotReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for readSlotCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = readSlotReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "readSlot(address,uint256)";
            const SELECTOR: [u8; 4] = [253u8, 176u8, 112u8, 165u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.l1_contract,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.slot),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `readString(address,uint256)` and selector `0xc4e1b1a9`.
```solidity
function readString(address l1_contract, uint256 slot) external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readStringCall {
        pub l1_contract: alloy::sol_types::private::Address,
        pub slot: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`readString(address,uint256)`](readStringCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readStringReturn {
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readStringCall> for UnderlyingRustTuple<'_> {
                fn from(value: readStringCall) -> Self {
                    (value.l1_contract, value.slot)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readStringCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        l1_contract: tuple.0,
                        slot: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readStringReturn> for UnderlyingRustTuple<'_> {
                fn from(value: readStringReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readStringReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for readStringCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = readStringReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "readString(address,uint256)";
            const SELECTOR: [u8; 4] = [196u8, 225u8, 177u8, 169u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.l1_contract,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.slot),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `readUint(address,uint256)` and selector `0xa17a41a1`.
```solidity
function readUint(address l1_contract, uint256 slot) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readUintCall {
        pub l1_contract: alloy::sol_types::private::Address,
        pub slot: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`readUint(address,uint256)`](readUintCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readUintReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readUintCall> for UnderlyingRustTuple<'_> {
                fn from(value: readUintCall) -> Self {
                    (value.l1_contract, value.slot)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readUintCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        l1_contract: tuple.0,
                        slot: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readUintReturn> for UnderlyingRustTuple<'_> {
                fn from(value: readUintReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readUintReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for readUintCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = readUintReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "readUint(address,uint256)";
            const SELECTOR: [u8; 4] = [161u8, 122u8, 65u8, 161u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.l1_contract,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.slot),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `readUint128(address,uint256)` and selector `0x51b5c4cd`.
```solidity
function readUint128(address l1_contract, uint256 slot) external view returns (uint128);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readUint128Call {
        pub l1_contract: alloy::sol_types::private::Address,
        pub slot: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`readUint128(address,uint256)`](readUint128Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readUint128Return {
        pub _0: u128,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readUint128Call> for UnderlyingRustTuple<'_> {
                fn from(value: readUint128Call) -> Self {
                    (value.l1_contract, value.slot)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readUint128Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        l1_contract: tuple.0,
                        slot: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<128>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u128,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readUint128Return> for UnderlyingRustTuple<'_> {
                fn from(value: readUint128Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readUint128Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for readUint128Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = readUint128Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<128>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "readUint128(address,uint256)";
            const SELECTOR: [u8; 4] = [81u8, 181u8, 196u8, 205u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.l1_contract,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.slot),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `readUint160(address,uint256)` and selector `0xac09f5df`.
```solidity
function readUint160(address l1_contract, uint256 slot) external view returns (uint160);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readUint160Call {
        pub l1_contract: alloy::sol_types::private::Address,
        pub slot: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`readUint160(address,uint256)`](readUint160Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readUint160Return {
        pub _0: alloy::sol_types::private::primitives::aliases::U160,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readUint160Call> for UnderlyingRustTuple<'_> {
                fn from(value: readUint160Call) -> Self {
                    (value.l1_contract, value.slot)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readUint160Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        l1_contract: tuple.0,
                        slot: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<160>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U160,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readUint160Return> for UnderlyingRustTuple<'_> {
                fn from(value: readUint160Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readUint160Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for readUint160Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = readUint160Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<160>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "readUint160(address,uint256)";
            const SELECTOR: [u8; 4] = [172u8, 9u8, 245u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.l1_contract,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.slot),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `readUint24(address,uint256)` and selector `0xbc0b03c9`.
```solidity
function readUint24(address l1_contract, uint256 slot) external view returns (uint24);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readUint24Call {
        pub l1_contract: alloy::sol_types::private::Address,
        pub slot: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`readUint24(address,uint256)`](readUint24Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readUint24Return {
        pub _0: alloy::sol_types::private::primitives::aliases::U24,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readUint24Call> for UnderlyingRustTuple<'_> {
                fn from(value: readUint24Call) -> Self {
                    (value.l1_contract, value.slot)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readUint24Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        l1_contract: tuple.0,
                        slot: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<24>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U24,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readUint24Return> for UnderlyingRustTuple<'_> {
                fn from(value: readUint24Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readUint24Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for readUint24Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = readUint24Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<24>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "readUint24(address,uint256)";
            const SELECTOR: [u8; 4] = [188u8, 11u8, 3u8, 201u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.l1_contract,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.slot),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `readUint32(address,uint256)` and selector `0xa2a81a78`.
```solidity
function readUint32(address l1_contract, uint256 slot) external view returns (uint32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readUint32Call {
        pub l1_contract: alloy::sol_types::private::Address,
        pub slot: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`readUint32(address,uint256)`](readUint32Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readUint32Return {
        pub _0: u32,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readUint32Call> for UnderlyingRustTuple<'_> {
                fn from(value: readUint32Call) -> Self {
                    (value.l1_contract, value.slot)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readUint32Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        l1_contract: tuple.0,
                        slot: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u32,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readUint32Return> for UnderlyingRustTuple<'_> {
                fn from(value: readUint32Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readUint32Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for readUint32Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = readUint32Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "readUint32(address,uint256)";
            const SELECTOR: [u8; 4] = [162u8, 168u8, 26u8, 120u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.l1_contract,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.slot),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `readUint48(address,uint256)` and selector `0xd6456505`.
```solidity
function readUint48(address l1_contract, uint256 slot) external view returns (uint48);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readUint48Call {
        pub l1_contract: alloy::sol_types::private::Address,
        pub slot: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`readUint48(address,uint256)`](readUint48Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readUint48Return {
        pub _0: alloy::sol_types::private::primitives::aliases::U48,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readUint48Call> for UnderlyingRustTuple<'_> {
                fn from(value: readUint48Call) -> Self {
                    (value.l1_contract, value.slot)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readUint48Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        l1_contract: tuple.0,
                        slot: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<48>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U48,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readUint48Return> for UnderlyingRustTuple<'_> {
                fn from(value: readUint48Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readUint48Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for readUint48Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = readUint48Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<48>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "readUint48(address,uint256)";
            const SELECTOR: [u8; 4] = [214u8, 69u8, 101u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.l1_contract,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.slot),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `readUint64(address,uint256)` and selector `0x06fa8823`.
```solidity
function readUint64(address l1_contract, uint256 slot) external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readUint64Call {
        pub l1_contract: alloy::sol_types::private::Address,
        pub slot: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`readUint64(address,uint256)`](readUint64Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readUint64Return {
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readUint64Call> for UnderlyingRustTuple<'_> {
                fn from(value: readUint64Call) -> Self {
                    (value.l1_contract, value.slot)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readUint64Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        l1_contract: tuple.0,
                        slot: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readUint64Return> for UnderlyingRustTuple<'_> {
                fn from(value: readUint64Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readUint64Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for readUint64Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = readUint64Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "readUint64(address,uint256)";
            const SELECTOR: [u8; 4] = [6u8, 250u8, 136u8, 35u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.l1_contract,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.slot),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `readUint8(address,uint256)` and selector `0x8af77671`.
```solidity
function readUint8(address l1_contract, uint256 slot) external view returns (uint8);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readUint8Call {
        pub l1_contract: alloy::sol_types::private::Address,
        pub slot: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`readUint8(address,uint256)`](readUint8Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readUint8Return {
        pub _0: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readUint8Call> for UnderlyingRustTuple<'_> {
                fn from(value: readUint8Call) -> Self {
                    (value.l1_contract, value.slot)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readUint8Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        l1_contract: tuple.0,
                        slot: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u8,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readUint8Return> for UnderlyingRustTuple<'_> {
                fn from(value: readUint8Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readUint8Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for readUint8Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = readUint8Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "readUint8(address,uint256)";
            const SELECTOR: [u8; 4] = [138u8, 247u8, 118u8, 113u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.l1_contract,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.slot),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `readUint96(address,uint256)` and selector `0x51987477`.
```solidity
function readUint96(address l1_contract, uint256 slot) external view returns (uint96);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readUint96Call {
        pub l1_contract: alloy::sol_types::private::Address,
        pub slot: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`readUint96(address,uint256)`](readUint96Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readUint96Return {
        pub _0: alloy::sol_types::private::primitives::aliases::U96,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readUint96Call> for UnderlyingRustTuple<'_> {
                fn from(value: readUint96Call) -> Self {
                    (value.l1_contract, value.slot)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readUint96Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        l1_contract: tuple.0,
                        slot: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<96>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U96,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readUint96Return> for UnderlyingRustTuple<'_> {
                fn from(value: readUint96Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readUint96Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for readUint96Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = readUint96Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<96>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "readUint96(address,uint256)";
            const SELECTOR: [u8; 4] = [81u8, 152u8, 116u8, 119u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.l1_contract,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.slot),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`L1Scroller`](self) function calls.
    pub enum L1ScrollerCalls {
        bytes32ToString(bytes32ToStringCall),
        bytesToUint(bytesToUintCall),
        readAddress(readAddressCall),
        readMultipleSlots(readMultipleSlotsCall),
        readSlot(readSlotCall),
        readString(readStringCall),
        readUint(readUintCall),
        readUint128(readUint128Call),
        readUint160(readUint160Call),
        readUint24(readUint24Call),
        readUint32(readUint32Call),
        readUint48(readUint48Call),
        readUint64(readUint64Call),
        readUint8(readUint8Call),
        readUint96(readUint96Call),
    }
    #[automatically_derived]
    impl L1ScrollerCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [2u8, 208u8, 109u8, 5u8],
            [6u8, 250u8, 136u8, 35u8],
            [38u8, 254u8, 229u8, 216u8],
            [81u8, 152u8, 116u8, 119u8],
            [81u8, 181u8, 196u8, 205u8],
            [138u8, 247u8, 118u8, 113u8],
            [146u8, 1u8, 222u8, 85u8],
            [161u8, 122u8, 65u8, 161u8],
            [162u8, 168u8, 26u8, 120u8],
            [172u8, 9u8, 245u8, 223u8],
            [186u8, 231u8, 37u8, 101u8],
            [188u8, 11u8, 3u8, 201u8],
            [196u8, 225u8, 177u8, 169u8],
            [214u8, 69u8, 101u8, 5u8],
            [253u8, 176u8, 112u8, 165u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for L1ScrollerCalls {
        const NAME: &'static str = "L1ScrollerCalls";
        const MIN_DATA_LENGTH: usize = 32usize;
        const COUNT: usize = 15usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::bytes32ToString(_) => {
                    <bytes32ToStringCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bytesToUint(_) => {
                    <bytesToUintCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::readAddress(_) => {
                    <readAddressCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::readMultipleSlots(_) => {
                    <readMultipleSlotsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::readSlot(_) => <readSlotCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::readString(_) => {
                    <readStringCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::readUint(_) => <readUintCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::readUint128(_) => {
                    <readUint128Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::readUint160(_) => {
                    <readUint160Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::readUint24(_) => {
                    <readUint24Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::readUint32(_) => {
                    <readUint32Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::readUint48(_) => {
                    <readUint48Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::readUint64(_) => {
                    <readUint64Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::readUint8(_) => {
                    <readUint8Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::readUint96(_) => {
                    <readUint96Call as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(unsafe_code, non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<L1ScrollerCalls>] = &[
                {
                    fn bytesToUint(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<L1ScrollerCalls> {
                        <bytesToUintCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(L1ScrollerCalls::bytesToUint)
                    }
                    bytesToUint
                },
                {
                    fn readUint64(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<L1ScrollerCalls> {
                        <readUint64Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(L1ScrollerCalls::readUint64)
                    }
                    readUint64
                },
                {
                    fn readMultipleSlots(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<L1ScrollerCalls> {
                        <readMultipleSlotsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(L1ScrollerCalls::readMultipleSlots)
                    }
                    readMultipleSlots
                },
                {
                    fn readUint96(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<L1ScrollerCalls> {
                        <readUint96Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(L1ScrollerCalls::readUint96)
                    }
                    readUint96
                },
                {
                    fn readUint128(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<L1ScrollerCalls> {
                        <readUint128Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(L1ScrollerCalls::readUint128)
                    }
                    readUint128
                },
                {
                    fn readUint8(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<L1ScrollerCalls> {
                        <readUint8Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(L1ScrollerCalls::readUint8)
                    }
                    readUint8
                },
                {
                    fn bytes32ToString(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<L1ScrollerCalls> {
                        <bytes32ToStringCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(L1ScrollerCalls::bytes32ToString)
                    }
                    bytes32ToString
                },
                {
                    fn readUint(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<L1ScrollerCalls> {
                        <readUintCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(L1ScrollerCalls::readUint)
                    }
                    readUint
                },
                {
                    fn readUint32(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<L1ScrollerCalls> {
                        <readUint32Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(L1ScrollerCalls::readUint32)
                    }
                    readUint32
                },
                {
                    fn readUint160(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<L1ScrollerCalls> {
                        <readUint160Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(L1ScrollerCalls::readUint160)
                    }
                    readUint160
                },
                {
                    fn readAddress(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<L1ScrollerCalls> {
                        <readAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(L1ScrollerCalls::readAddress)
                    }
                    readAddress
                },
                {
                    fn readUint24(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<L1ScrollerCalls> {
                        <readUint24Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(L1ScrollerCalls::readUint24)
                    }
                    readUint24
                },
                {
                    fn readString(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<L1ScrollerCalls> {
                        <readStringCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(L1ScrollerCalls::readString)
                    }
                    readString
                },
                {
                    fn readUint48(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<L1ScrollerCalls> {
                        <readUint48Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(L1ScrollerCalls::readUint48)
                    }
                    readUint48
                },
                {
                    fn readSlot(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<L1ScrollerCalls> {
                        <readSlotCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(L1ScrollerCalls::readSlot)
                    }
                    readSlot
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            (unsafe { DECODE_SHIMS.get_unchecked(idx) })(data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::bytes32ToString(inner) => {
                    <bytes32ToStringCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::bytesToUint(inner) => {
                    <bytesToUintCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::readAddress(inner) => {
                    <readAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::readMultipleSlots(inner) => {
                    <readMultipleSlotsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::readSlot(inner) => {
                    <readSlotCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::readString(inner) => {
                    <readStringCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::readUint(inner) => {
                    <readUintCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::readUint128(inner) => {
                    <readUint128Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::readUint160(inner) => {
                    <readUint160Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::readUint24(inner) => {
                    <readUint24Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::readUint32(inner) => {
                    <readUint32Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::readUint48(inner) => {
                    <readUint48Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::readUint64(inner) => {
                    <readUint64Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::readUint8(inner) => {
                    <readUint8Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::readUint96(inner) => {
                    <readUint96Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::bytes32ToString(inner) => {
                    <bytes32ToStringCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bytesToUint(inner) => {
                    <bytesToUintCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::readAddress(inner) => {
                    <readAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::readMultipleSlots(inner) => {
                    <readMultipleSlotsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::readSlot(inner) => {
                    <readSlotCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::readString(inner) => {
                    <readStringCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::readUint(inner) => {
                    <readUintCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::readUint128(inner) => {
                    <readUint128Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::readUint160(inner) => {
                    <readUint160Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::readUint24(inner) => {
                    <readUint24Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::readUint32(inner) => {
                    <readUint32Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::readUint48(inner) => {
                    <readUint48Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::readUint64(inner) => {
                    <readUint64Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::readUint8(inner) => {
                    <readUint8Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::readUint96(inner) => {
                    <readUint96Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`L1Scroller`](self) contract instance.

See the [wrapper's documentation](`L1ScrollerInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> L1ScrollerInstance<T, P, N> {
        L1ScrollerInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<L1ScrollerInstance<T, P, N>>,
    > {
        L1ScrollerInstance::<T, P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
        L1ScrollerInstance::<T, P, N>::deploy_builder(provider)
    }
    /**A [`L1Scroller`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`L1Scroller`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct L1ScrollerInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for L1ScrollerInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("L1ScrollerInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > L1ScrollerInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`L1Scroller`](self) contract instance.

See the [wrapper's documentation](`L1ScrollerInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<L1ScrollerInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> L1ScrollerInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> L1ScrollerInstance<T, P, N> {
            L1ScrollerInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > L1ScrollerInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`bytes32ToString`] function.
        pub fn bytes32ToString(
            &self,
            _bytes32: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, bytes32ToStringCall, N> {
            self.call_builder(&bytes32ToStringCall { _bytes32 })
        }
        ///Creates a new call builder for the [`bytesToUint`] function.
        pub fn bytesToUint(
            &self,
            b: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, bytesToUintCall, N> {
            self.call_builder(&bytesToUintCall { b })
        }
        ///Creates a new call builder for the [`readAddress`] function.
        pub fn readAddress(
            &self,
            l1_contract: alloy::sol_types::private::Address,
            slot: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, readAddressCall, N> {
            self.call_builder(
                &readAddressCall {
                    l1_contract,
                    slot,
                },
            )
        }
        ///Creates a new call builder for the [`readMultipleSlots`] function.
        pub fn readMultipleSlots(
            &self,
            l1_contract: alloy::sol_types::private::Address,
            slot: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, readMultipleSlotsCall, N> {
            self.call_builder(
                &readMultipleSlotsCall {
                    l1_contract,
                    slot,
                },
            )
        }
        ///Creates a new call builder for the [`readSlot`] function.
        pub fn readSlot(
            &self,
            l1_contract: alloy::sol_types::private::Address,
            slot: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, readSlotCall, N> {
            self.call_builder(&readSlotCall { l1_contract, slot })
        }
        ///Creates a new call builder for the [`readString`] function.
        pub fn readString(
            &self,
            l1_contract: alloy::sol_types::private::Address,
            slot: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, readStringCall, N> {
            self.call_builder(
                &readStringCall {
                    l1_contract,
                    slot,
                },
            )
        }
        ///Creates a new call builder for the [`readUint`] function.
        pub fn readUint(
            &self,
            l1_contract: alloy::sol_types::private::Address,
            slot: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, readUintCall, N> {
            self.call_builder(&readUintCall { l1_contract, slot })
        }
        ///Creates a new call builder for the [`readUint128`] function.
        pub fn readUint128(
            &self,
            l1_contract: alloy::sol_types::private::Address,
            slot: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, readUint128Call, N> {
            self.call_builder(
                &readUint128Call {
                    l1_contract,
                    slot,
                },
            )
        }
        ///Creates a new call builder for the [`readUint160`] function.
        pub fn readUint160(
            &self,
            l1_contract: alloy::sol_types::private::Address,
            slot: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, readUint160Call, N> {
            self.call_builder(
                &readUint160Call {
                    l1_contract,
                    slot,
                },
            )
        }
        ///Creates a new call builder for the [`readUint24`] function.
        pub fn readUint24(
            &self,
            l1_contract: alloy::sol_types::private::Address,
            slot: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, readUint24Call, N> {
            self.call_builder(
                &readUint24Call {
                    l1_contract,
                    slot,
                },
            )
        }
        ///Creates a new call builder for the [`readUint32`] function.
        pub fn readUint32(
            &self,
            l1_contract: alloy::sol_types::private::Address,
            slot: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, readUint32Call, N> {
            self.call_builder(
                &readUint32Call {
                    l1_contract,
                    slot,
                },
            )
        }
        ///Creates a new call builder for the [`readUint48`] function.
        pub fn readUint48(
            &self,
            l1_contract: alloy::sol_types::private::Address,
            slot: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, readUint48Call, N> {
            self.call_builder(
                &readUint48Call {
                    l1_contract,
                    slot,
                },
            )
        }
        ///Creates a new call builder for the [`readUint64`] function.
        pub fn readUint64(
            &self,
            l1_contract: alloy::sol_types::private::Address,
            slot: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, readUint64Call, N> {
            self.call_builder(
                &readUint64Call {
                    l1_contract,
                    slot,
                },
            )
        }
        ///Creates a new call builder for the [`readUint8`] function.
        pub fn readUint8(
            &self,
            l1_contract: alloy::sol_types::private::Address,
            slot: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, readUint8Call, N> {
            self.call_builder(&readUint8Call { l1_contract, slot })
        }
        ///Creates a new call builder for the [`readUint96`] function.
        pub fn readUint96(
            &self,
            l1_contract: alloy::sol_types::private::Address,
            slot: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, readUint96Call, N> {
            self.call_builder(
                &readUint96Call {
                    l1_contract,
                    slot,
                },
            )
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > L1ScrollerInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
